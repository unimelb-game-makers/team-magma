Index: Assets/Scripts/Player/PlayerController.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System;\nusing Damage;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing Platforms;\nusing Utilities.ServiceLocator;\n\nnamespace Player\n{\n    public class PlayerController : MonoBehaviour\n    {\n        // Movement speed of the player\n        [Header(\"Movement Setup\")]\n        [SerializeField] private float movementSpeed = 15f;\n        [SerializeField] private OrientationType orientation;\n\n        [Space(10)]\n\n        [Header(\"Attack Setup\")]\n        [SerializeField] private GameObject projectilePrefab;\n        [SerializeField] private LayerMask enemyLayers;  // The layers that should be considered as enemies\n        [SerializeField] private float rotationSpeed = 10f;  // Speed at which the player rotates\n        [SerializeField] private GameObject MeleeAttackPrefab;\n        [SerializeField] private float hitRange = 0.5f;\n        [SerializeField] private float meleeAttackRecoverTime = 0.7f;\n\n        [Space(10)]\n\n        [Header(\"Dodge Setup\")]\n        [SerializeField] private float dodgeSpeed = 40f;\n        [SerializeField] private float dodgeRecoverTime = 1f;\n        [SerializeField] private float dodgeTime = 0.15f;\n        [SerializeField] private float isInvulnerableTime = 0.1f;\n\n\n        public enum OrientationType\n        {\n            TowardMouse,\n            BasedOnInput\n        }\n\n        // Rigidbody component for physics-based movement\n        private Rigidbody _rigidbody;\n\n        private bool _leftMouseButtonDown;\n\n        private bool _leftShiftButtonDown;\n\n        private bool _DodgeButtonDown;\n\n        private Camera _mainCamera;  // Reference to the main camera\n\n        private MeleeAttackBox _meleeAttackBox = null;\n\n        private float _previousMeleeAttack;\n\n        private bool _isMovingHorizontally;\n        private bool _isMovingVertically;\n        private float _previousDodge;\n        private Vector3 _dodgeDirection;\n        private float _horizontalInput;\n        private float _verticalInput;\n        private void Start()\n        {\n            // Get the Rigidbody component attached to this GameObject\n            _rigidbody = GetComponent<Rigidbody>();\n            if (_rigidbody == null)\n            {\n                Debug.LogError(\"Rigidbody component is missing from the player object.\");\n            }\n            // Get the main camera\n            _mainCamera = Camera.main;\n\n            _previousMeleeAttack = Time.time - meleeAttackRecoverTime;\n            _previousDodge = Time.time - dodgeRecoverTime;\n        }\n\n        private void Update()\n        {\n            _horizontalInput = Input.GetAxis(\"Horizontal\");\n            _verticalInput = Input.GetAxis(\"Vertical\");\n\n            TrackMovementInput();\n\n            Move();\n\n            Rotate();\n\n            Attack();\n        }\n\n        private void FixedUpdate()\n        {\n            //Move();\n\n            //Rotate();\n\n            //Attack();\n        }\n\n        private void Attack()\n        {\n            //if the player has attacked need to release the mouse to attack again\n            if (Input.GetButtonDown(\"Fire1\") && !_leftMouseButtonDown)\n            {\n                Fire(GetMouseWorldPosition());\n                _leftMouseButtonDown = true;\n            }\n\n            if (Input.GetButtonUp(\"Fire1\"))\n            {\n                _leftMouseButtonDown = false;\n            }\n\n            if (Input.GetButtonDown(\"Fire3\") && !_leftShiftButtonDown)\n            {\n                MeleeAttack(GetMouseWorldPosition());\n                Debug.LogError(\"Melee attack\");\n                _leftShiftButtonDown = true;\n            }\n\n            if (Input.GetButtonUp(\"Fire3\"))\n            {\n                _leftShiftButtonDown = false;\n            }\n            \n            if (Input.GetButtonDown(\"Fire2\"))\n            {\n                PlayTapeEffect();\n            }\n        }\n\n        private void Move()\n        {\n            // Get input from the horizontal and vertical axes\n            \n\n            if (Input.GetButtonDown(\"Dodge\") && !_DodgeButtonDown && Time.time > _previousDodge + dodgeRecoverTime)\n            {\n                _dodgeDirection = new Vector3(_horizontalInput, 0, _verticalInput);\n                _previousDodge = Time.time;\n                _DodgeButtonDown = true;\n\n                if (!TrackMovementInput()) {\n                    // Move toward the direction the player is facing\n                    _dodgeDirection = transform.forward;\n                }\n\n                GetComponent<Damage.Damageable>().setIsInvulnerable(true);\n            }\n\n            if (Input.GetButtonUp(\"Dodge\"))\n            { \n                _DodgeButtonDown = false;\n            }\n\n            if (Time.time > _previousDodge + isInvulnerableTime && GetComponent<Damageable>().getIsInvulnerable()) {\n                GetComponent<Damageable>().setIsInvulnerable(false);\n            }\n\n            if (Time.time > _previousDodge && Time.time < _previousDodge + dodgeTime)\n            // If boost of movement is needed (for dodge)\n            {\n                // Apply the movement to the Rigidbody\n                _rigidbody.MovePosition(_rigidbody.position + _dodgeDirection * dodgeSpeed * Time.deltaTime);\n            }\n            else\n            {\n                Vector3 movement;\n                // Calculate the movement vector\n                //Slow down the speed by 1/sqrt(2) if both keys pressed\n                if (_isMovingHorizontally && _isMovingVertically)\n                {\n                    movement = new Vector3(_horizontalInput * movementSpeed * 0.69f, _rigidbody.velocity.y, _verticalInput * movementSpeed * 0.69f);\n                }\n                else\n                {\n                    movement = new Vector3(_horizontalInput * movementSpeed, _rigidbody.velocity.y, _verticalInput * movementSpeed);\n                }\n\n                // Apply the movement to the Rigidbody\n                //_rigidbody.MovePosition(_rigidbody.position + movement * Time.deltaTime);\n\n                // Apply velocity to the Rigidbody\n                _rigidbody.velocity = movement;\n            }\n        }\n        \n\n        private void Fire(Vector3 targetPosition)\n        {\n            //spawn a projectile\n            GameObject projectile = Instantiate(projectilePrefab, transform.position, transform.rotation);\n            //get the Projectile component from the projectile object\n            Projectile projectileComponent = projectile.GetComponent<Projectile>();\n            //check if the Projectile component exists\n            if (projectileComponent != null)\n            {\n                var canAttackList = new List<string> { \"Enemy\" };\n                projectileComponent.SendMessage(\"EditCanAttack\", canAttackList);\n\n                //set the initial direction of the projectile\n                projectileComponent.SetInitialDirection((targetPosition - transform.position).normalized);\n            }\n        }\n\n        private Vector3 GetMouseWorldPosition()\n        {\n            // Create a ray from the camera to the mouse position\n            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n            // Create a plane at the player's position with normal facing up\n            Plane plane = new Plane(Vector3.up, transform.position);\n            // Calculate the distance from the ray origin to the plane\n            if (plane.Raycast(ray, out float distance))\n            {\n                // Get the point on the plane where the ray intersects\n                Vector3 hitPoint = ray.GetPoint(distance);\n                return hitPoint;\n            }\n            return Vector3.zero;\n        }\n\n        private void MeleeAttack(Vector3 targetPosition)\n        {\n            Vector3 origin = transform.position;\n            Vector3 forward = (transform.forward * hitRange) + origin;\n\n            if (_meleeAttackBox == null && Time.time > _previousMeleeAttack + meleeAttackRecoverTime) {\n                _previousMeleeAttack = Time.time;\n                GameObject attackBox = Instantiate(MeleeAttackPrefab, forward, transform.rotation);\n                _meleeAttackBox = attackBox.GetComponent<MeleeAttackBox>();\n                _meleeAttackBox.transform.parent = gameObject.transform;\n                if (_meleeAttackBox != null)\n                {\n                    var canAttackList = new List<string> { \"Enemy\" };\n                    _meleeAttackBox.SendMessage(\"EditCanAttack\", canAttackList);\n                }\n            }\n        }\n\n        \n        /**\n         * Placeholder for playing the tape effect\n         */\n        private void PlayTapeEffect()\n        {\n            //get IAffectServices from service locator\n            var affectServices = ServiceLocator.Instance.Get<IAffectService>();\n            foreach (var o in affectServices)\n            {\n                o.Affect(TapeType.Slow, 5, 0.5f);\n            }\n        }\n\n        void Rotate()\n        {\n            Quaternion targetRotation;\n            switch (orientation)\n            {\n                case OrientationType.BasedOnInput:\n                    if (TrackMovementInput()) {\n                        targetRotation = Quaternion.LookRotation(new Vector3(_horizontalInput, 0, _verticalInput));\n                        // Smoothly rotate towards the target rotation\n                        transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, Time.deltaTime * rotationSpeed);\n                    }\n                    break;\n                case OrientationType.TowardMouse:\n                    // Get the mouse position in the world space\n                    Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition);\n                    Plane groundPlane = new Plane(Vector3.up, Vector3.zero);  // Define a plane at the ground level\n\n                    // Check where the ray intersects the plane\n                    if (groundPlane.Raycast(ray, out float distance))\n                    {\n                        Vector3 targetPoint = ray.GetPoint(distance);  // Get the point on the plane\n                        Vector3 direction = (targetPoint - transform.position).normalized;  // Calculate the direction\n\n                        targetRotation = Quaternion.LookRotation(new Vector3(direction.x, 0, direction.z));\n                        // Smoothly rotate towards the target rotation\n                        transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, Time.deltaTime * rotationSpeed);\n                    }\n                    break;\n            }\n        }\n\n        private bool TrackMovementInput()\n        {\n            if (Input.GetButtonDown(\"Horizontal\"))\n            {\n                _isMovingHorizontally = true;\n            }\n            if (Input.GetButtonDown(\"Vertical\"))\n            {\n                _isMovingVertically = true; \n            }\n            if (Input.GetButtonUp(\"Horizontal\"))\n            {\n                _isMovingHorizontally = false;\n            }\n            if (Input.GetButtonUp(\"Vertical\"))\n            {\n                _isMovingVertically = false; \n            }\n            return _isMovingHorizontally || _isMovingVertically;\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Player/PlayerController.cs b/Assets/Scripts/Player/PlayerController.cs
--- a/Assets/Scripts/Player/PlayerController.cs	
+++ b/Assets/Scripts/Player/PlayerController.cs	
@@ -14,7 +14,8 @@
         [Header("Movement Setup")]
         [SerializeField] private float movementSpeed = 15f;
         [SerializeField] private OrientationType orientation;
-
+        [SerializeField] private float jumpHeight = 2.0f;
+        [SerializeField] private float jumpForce = 2.0f;
         [Space(10)]
 
         [Header("Attack Setup")]
@@ -57,6 +58,8 @@
 
         private bool _isMovingHorizontally;
         private bool _isMovingVertically;
+        private bool _isGrounded = true;
+        
         private float _previousDodge;
         private Vector3 _dodgeDirection;
         private float _horizontalInput;
@@ -116,7 +119,7 @@
             if (Input.GetButtonDown("Fire3") && !_leftShiftButtonDown)
             {
                 MeleeAttack(GetMouseWorldPosition());
-                Debug.LogError("Melee attack");
+                //Debug.LogError("Melee attack");
                 _leftShiftButtonDown = true;
             }
 
@@ -185,6 +188,13 @@
                 // Apply velocity to the Rigidbody
                 _rigidbody.velocity = movement;
             }
+            
+            if (Input.GetButtonDown("Jump") && _isGrounded){
+    
+                _rigidbody.AddForce(new Vector3(0.0f, jumpHeight, 0.0f) * jumpForce, ForceMode.Impulse);
+                _isGrounded = false;
+            }
+            
         }
         
 
@@ -304,5 +314,10 @@
             }
             return _isMovingHorizontally || _isMovingVertically;
         }
+
+        private void OnCollisionStay()
+        {
+            _isGrounded = true;
+        }
     }
 }
\ No newline at end of file
